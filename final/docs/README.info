threading.Thread: el sentido de hacer un programa en Python que despliegue dos hilos, uno para aceptar conexiones IPv4 y otro para aceptar conexiones IPv6, es aprovechar al máximo los recursos del sistema y ofrecer soporte para ambos tipos de conexiones de red. Al desplegar dos hilos para manejar las conexiones, el programa puede aceptar conexiones entrantes en paralelo para ambos protocolos sin bloquear la ejecución de otros procesos. Esto permite que el programa maneje un mayor número de conexiones y ofrezca una mejor experiencia de usuario.

socketserver: lo utilicé ya que a diferencia de socket,  simplifica la creación de servidores socket al proporcionar una API de nivel superior. ForkedTCPServer es una subclase del módulo SocketServer de Python que se basa en la clase TCPServer y utiliza el mixin ForkingMixIn para implementar la creación de procesos hijos encargados de manejar las conexiones entrantes. Básicamente, cada vez que se establece una conexión TCP entrante, se crea un proceso hijo independiente para manejarla de manera exclusiva, lo que ayuda a mejorar significativamente la escalabilidad del servidor. Al tener x procesos hijos manejando las x conexiones entrantes de forma simultánea e independiente, se logra un mejor rendimiento del servidor y una mayor capacidad para atender múltiples solicitudes al mismo tiempo.

multiprocessing.Lock(): lo utilice para sincronizar el acceso al recurso compartido entre procesos Hijo (log.txt). Cuando varios procesos necesitan acceder a un mismo recurso, es posible que se produzca una condición de carrera, donde dos o más procesos intentan modificar el recurso al mismo tiempo y los cambios pueden perderse o provocar resultados inesperados. Lock garantiza que un solo proceso Hijo tengo acceso exclusivo al log.txt . 

sqlite3:  el sistema de gestión de bases de datos relacional utilizado es SQLite debido a que es ligero, rápido y fácil de usar. A diferencia de otros sistemas de gestión de bases de datos, como MySQL, SQLite no requiere un servidor dedicado, ya que la base de datos se almacena en un archivo que puede ser accedido directamente por la aplicación que la utiliza.

os.fork(): Aunque multiprocessing proporciona una abstracción de nivel superior y una forma más sencilla de crear procesos hijos y compartir datos entre ellos, opté por utilizar la llamada al sistema Unix "fork" para crear procesos hijos debido a su simplicidad.

multiprocessing.Pipe(): Elegí utilizar este mecanismo de IPC para comunicar el proceso Hijo con el proceso Nieto en lugar de multiprocessing.Queue() porque necesitaba una comunicación bidireccional (al crear dos pipes) entre ambos procesos. Si hubiera utilizado Queue, tendría que enviar una señal a Nieto cada vez que Hijo necesitara una pregunta, y luego Nieto tendría que buscar la pregunta en la BD, colocarla en la cola, y esperar a que Hijo la retirara. Además, tendría que especificar otras señales diferentes para que el Nieto sepa cuando actualizar el puntaje y cuando obtener el ranking. En conclusión, encontré que Pipe era más eficiente para este caso específico, ya que permitió una comunicación bidireccional más directa y rápida entre Hijo y Nieto sin necesidad de implementar señales y sin tener que esperar a que Nieto colocara la pregunta en la cola.

pickle : utilicé este mecanismo que implementa protocolos binarios para transferir ifnromación serializada entre diferentes máquinas. 